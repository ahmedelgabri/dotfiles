#!/usr/bin/env bash
set -ue -o pipefail

CMD="git"
if [[ -n "${DEUBG-}" ]]; then
	set -x

	CMD="echo git"
fi

get_worktree_branch() {
	# We get grep for the worktree name, then we extract the branch name from the result
	# Because a worktree name is not always the branch name
	local BRANCH
	BRANCH=$(git worktree list | grep "${1-}" | sed -E 's/.*\s+[a-zA-Z0-9]+\s\[(.*)\]/\1/g')
	# local BRANCH=$(git -C "${1-}" branch --show-current)

	# check if branch has the string (detached HEAD)
	if [[ "$BRANCH" == *"(detached HEAD)"* ]]; then
		# If it does, then we get the branch name from the HEAD
		echo ""
	fi

	echo "$BRANCH"
}

case $1 in
# This is an extra command that I added to handle cloning a repo and setting it
# up as a worktree
clone)
	shift
	FOLDER_NAME=${2:-$(basename "$1" ".git")}

	mkdir -p "$FOLDER_NAME"

	cd "$FOLDER_NAME"

	$CMD clone --bare "$1" .bare

	echo "gitdir: ./.bare" >.git

	$CMD config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"
	$CMD config core.logallrefupdates true

	$CMD fetch --all

	# Need to remove all local branches with invalid upstream refs
	# See: https://stackoverflow.com/a/54408181/213124
	$CMD for-each-ref --format='%(refname:short)' refs/heads | xargs git branch -D

	echo "Discovering default branch..."
	default_branch=$(git remote show origin | sed -n '/HEAD branch/s/.*: //p')

	if [ -n "$default_branch" ]; then
		echo "Creating initial worktree for the default branch (origin/$default_branch)..."
		git worktree add -B "$default_branch" "$default_branch" "origin/$default_branch"
	fi

	;;
add)
	shift
	BRANCH=""
	ARGS=()
	while [[ $# -gt 0 ]]; do
		if [[ $1 == "-b" ]]; then
			BRANCH=$2
			ARGS+=("$1" "$2")
			shift 2
		else
			ARGS+=("$1")
			shift
		fi
	done

	$CMD worktree add "${ARGS[@]}"

	if [[ -n "$BRANCH" ]]; then
		$CMD branch --set-upstream-to="origin/$BRANCH" "$BRANCH"
	fi

	$CMD fetch --all --prune
	;;
remove | rm)
	shift

	if [[ -z "${1-}" ]]; then
		git worktree list | grep -v ".bare" | fzf \
			--header $'CTRL-X (remove worktree)\n\n' \
			--bind 'enter:become(git worktree remove -f {1} && git branch -D $(echo {3} | sed -E "s/\[(.*)\]/\1/g"))' \
			--bind 'ctrl-x:reload(git worktree remove -f {1} && git branch -D $(echo {3} | sed -E "s/\[(.*)\]/\1/g"); git worktree list)' \
			--preview "
				git -c color.status=always -C {1} status --short --branch
				echo
				git log --oneline --graph --date=short --color=always --pretty='format:%C(auto)%cd %h%d %s' {2} --
			"
	fi

	BRANCH_TO_DELETE=$(get_worktree_branch "$1")

	$CMD worktree remove -f "$1"

	if [[ -n "$BRANCH_TO_DELETE" ]]; then
		$CMD branch -D "$BRANCH_TO_DELETE"
	fi
	;;
# Same as remove, but this time we also delete the branch from remote
destroy)
	shift

	BRANCH_TO_DELETE=$(get_worktree_branch "$1")

	EXTRTA_MSG=""
	if [[ -n "$BRANCH_TO_DELETE" ]]; then
		EXTRTA_MSG=" and delete its remote branch [$BRANCH_TO_DELETE]"
	fi

	printf "Are you sure you want to destroy '%s' workspace%s? [y/N]: " "$1" "$EXTRTA_MSG"
	read -r CONFIRMATION

	if [[ "$CONFIRMATION" != "y" ]]; then
		exit 1
	fi

	$CMD worktree remove -f "$1"

	if [[ -n "$BRANCH_TO_DELETE" ]]; then
		$CMD branch -D "$BRANCH_TO_DELETE"
		$CMD push origin --delete "$BRANCH_TO_DELETE"
	fi
	;;
list | lock | unlock | move | prune | repair)
	$CMD worktree "$@"
	;;

help | --help)
	$CMD worktree --help
	echo "--------------------------"
	cat <<-EOF
		git-wt clone <repo>
	EOF
	;;
*)
	# Let git worktree handle the errors
	$CMD worktree "$@"
	;;
esac
