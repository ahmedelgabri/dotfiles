#!/usr/bin/env bash
set -ue -o pipefail

# DEBUG mode strategy:
# - $CMD is used for mutation operations (clone, config, fetch, worktree add/remove, branch, push)
# - Direct git calls are used for read-only operations (worktree list, remote show, rev-parse, etc.)
# - When DEBUG=1, mutations are echoed without execution, reads run normally
CMD="git"
if [[ -n "${DEBUG-}" ]]; then
	set -x

	CMD="echo git"
fi

# Color output (respects NO_COLOR environment variable)
if [[ -z "${NO_COLOR-}" ]]; then
	GREEN=$'\033[32m'
	RED=$'\033[31m'
	YELLOW=$'\033[33m'
	RESET=$'\033[0m'
else
	GREEN=""
	RED=""
	YELLOW=""
	RESET=""
fi

# Check for required dependencies for interactive commands
check_fzf_dependency() {
	if ! command -v fzf >/dev/null 2>&1; then
		echo "Error: fzf is required for interactive mode" >&2
		echo "Install fzf: https://github.com/junegunn/fzf" >&2
		exit 1
	fi
}

# Worktree cache - populated once per invocation
# Avoids multiple calls to 'git worktree list --porcelain'
declare -A WORKTREE_CACHE_BRANCHES=() # path -> branch
declare -A WORKTREE_CACHE_PATHS=()    # branch -> path
declare -A WORKTREE_CACHE_HEADS=()    # path -> short SHA
WORKTREE_CACHE_LOADED=false

load_worktree_cache() {
	# Parse porcelain output once and populate all caches
	# The --porcelain format is stable across git versions:
	#   worktree /path/to/worktree
	#   HEAD abc123...
	#   branch refs/heads/branch-name
	#   <blank line>
	[[ "$WORKTREE_CACHE_LOADED" == true ]] && return 0

	local current_path="" current_branch="" current_head=""

	while IFS= read -r line; do
		case "$line" in
		worktree\ *)
			current_path="${line#worktree }"
			;;
		HEAD\ *)
			current_head="${line#HEAD }"
			current_head="${current_head:0:7}"
			;;
		branch\ *)
			current_branch="${line#branch refs/heads/}"
			;;
		detached)
			current_branch="(detached)"
			;;
		"")
			if [[ -n "$current_path" && "$current_path" != *".bare"* ]]; then
				WORKTREE_CACHE_BRANCHES["$current_path"]="$current_branch"
				WORKTREE_CACHE_HEADS["$current_path"]="$current_head"
				if [[ -n "$current_branch" && "$current_branch" != "(detached)" ]]; then
					WORKTREE_CACHE_PATHS["$current_branch"]="$current_path"
				fi
			fi
			current_path="" current_branch="" current_head=""
			;;
		esac
	done < <(git worktree list --porcelain)

	# Handle last entry (no trailing blank line)
	if [[ -n "$current_path" && "$current_path" != *".bare"* ]]; then
		WORKTREE_CACHE_BRANCHES["$current_path"]="$current_branch"
		WORKTREE_CACHE_HEADS["$current_path"]="$current_head"
		if [[ -n "$current_branch" && "$current_branch" != "(detached)" ]]; then
			WORKTREE_CACHE_PATHS["$current_branch"]="$current_path"
		fi
	fi

	WORKTREE_CACHE_LOADED=true
}

get_worktree_branch() {
	# Get the branch name for a given worktree path
	# Args: $1 = worktree path
	# Returns: branch name or empty if detached/not found
	load_worktree_cache
	echo "${WORKTREE_CACHE_BRANCHES[$1]:-}"
}

validate_worktree() {
	# Check if a path is a valid worktree
	# Args: $1 = worktree path
	load_worktree_cache
	if [[ -n "${WORKTREE_CACHE_BRANCHES[$1]+x}" ]]; then
		return 0
	fi
	echo "Error: '$1' is not a valid worktree" >&2
	return 1
}

get_worktree_list() {
	# Get list of worktrees as "path:branch:head" lines, excluding .bare
	# Output format: /path/to/worktree:branch-name:abc1234
	load_worktree_cache
	local path
	for path in "${!WORKTREE_CACHE_BRANCHES[@]}"; do
		echo "${path}:${WORKTREE_CACHE_BRANCHES[$path]}:${WORKTREE_CACHE_HEADS[$path]}"
	done
}

format_worktree_for_display() {
	# Convert "path:branch:head" format to display format for fzf
	# Input: /path/to/worktree:branch-name:abc1234
	# Output: /path/to/worktree abc1234 [branch-name]
	local entry=$1
	local wt_path="${entry%%:*}"
	local rest="${entry#*:}"
	local branch="${rest%%:*}"
	local commit="${rest##*:}"

	# Fallback if commit is empty
	[[ -z "$commit" ]] && commit="??????"

	if [[ -n "$branch" && "$branch" != "(detached)" ]]; then
		printf "%s %s [%s]\n" "$wt_path" "$commit" "$branch"
	else
		printf "%s %s (detached HEAD)\n" "$wt_path" "$commit"
	fi
}

extract_path_from_display_line() {
	# Extract worktree path from display format line
	# The path is the first whitespace-separated field
	echo "${1%% *}"
}

extract_branch_from_display_line() {
	# Extract branch name from display format line
	# Format: /path/to/worktree abc123 [branch-name]
	local line=$1

	if [[ "$line" =~ \[([^\]]+)\]$ ]]; then
		echo "${BASH_REMATCH[1]}"
	else
		echo ""
	fi
}

get_worktree_path_for_branch() {
	# Find the worktree path for a given branch name
	# Args: $1 = branch name
	# Returns: worktree path or empty if not found
	load_worktree_cache
	echo "${WORKTREE_CACHE_PATHS[$1]:-}"
}

get_default_branch() {
	# Get the default branch name, preferring local lookup over network
	# Returns: branch name (e.g., "main" or "master")
	local branch

	# Try local symbolic-ref first (instant, no network)
	branch=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null)
	if [[ -n "$branch" ]]; then
		echo "${branch#refs/remotes/origin/}"
		return 0
	fi

	# Fall back to network call
	git remote show origin 2>/dev/null | sed -n '/HEAD branch/s/.*: //p'
}

build_worktree_display_list() {
	# Build newline-separated display list of worktrees for fzf
	# Output: /path/to/worktree abc1234 [branch-name]
	local result="" entry display_line
	while IFS= read -r entry; do
		if [[ -n "$entry" ]]; then
			display_line=$(format_worktree_for_display "$entry")
			if [[ -n "$result" ]]; then
				result="${result}"$'\n'"${display_line}"
			else
				result="$display_line"
			fi
		fi
	done < <(get_worktree_list)
	echo "$result"
}

select_worktrees_interactive() {
	local mode=$1 # "remove" or "destroy"

	local WORKTREE_LIST
	WORKTREE_LIST=$(build_worktree_display_list)

	if [[ -z "$WORKTREE_LIST" ]]; then
		echo "No worktrees to $mode"
		exit 0
	fi

	local prompt header preview_extra

	if [[ "$mode" == "destroy" ]]; then
		prompt="Select worktree(s) to DESTROY (TAB to select multiple): "
		header="⚠️  WARNING: This will delete LOCAL and REMOTE branches
TAB: select/deselect | ENTER: confirm | ESC: cancel"
		preview_extra='cat <<-EOF
			⚠️  DESTROY MODE - PERMANENT DELETION

			Worktree: $WORKTREE_PATH
			Branch: $BRANCH

			This will:
			  1. Remove worktree directory
			  2. Delete local branch
			  3. Delete remote branch (origin/$BRANCH)
		EOF'
	else
		prompt="Select worktree(s) to remove (TAB to select multiple): "
		header="TAB: select/deselect | ENTER: confirm | ESC: cancel
Local branches will also be deleted (remote branches preserved)"
		preview_extra='cat <<-EOF
			Worktree: $WORKTREE_PATH
			Branch: $BRANCH
		EOF'
	fi

	SELECTED=$(
		echo "$WORKTREE_LIST" | fzf \
			--multi \
			--prompt="$prompt" \
			--height=60% \
			--border \
			--header="$header" \
			--preview="
				WORKTREE_PATH=\$(echo {} | awk '{print \$1}')
				BRANCH=\$(echo {} | sed -E 's/.*\[([^]]+)\].*/\1/')

				$preview_extra
				echo \"\"
				echo \"Status:\"
				git -c color.status=always -C \"\$WORKTREE_PATH\" status --short --branch 2>/dev/null || echo \"(unable to get status)\"
				echo \"\"
				echo \"Recent commits:\"
				git log --oneline --graph --date=short --color=always --pretty='format:%C(auto)%cd %h%d %s' \"\$BRANCH\" -10 -- 2>/dev/null || echo \"(unable to get log)\"
			" \
			--preview-window=right:60%:wrap
	)

	# User cancelled
	if [[ -z "$SELECTED" ]]; then
		echo "Cancelled"
		exit 0
	fi

	echo "$SELECTED"
}

validate_branch_name() {
	# Validate git branch name using git's own validation
	local branch_name=$1

	if [[ -z "$branch_name" ]]; then
		echo "Error: Branch name cannot be empty" >&2
		return 1
	fi

	if ! git check-ref-format --branch "$branch_name" >/dev/null 2>&1; then
		echo "Error: Invalid branch name '$branch_name'" >&2
		return 1
	fi

	return 0
}

parse_selected_worktrees() {
	# Parse fzf selection output into worktree paths and branch names
	# Args: $1 = fzf output (multiline string, display format)
	# Sets global arrays: WORKTREE_PATHS and BRANCH_NAMES
	local selected=$1
	WORKTREE_PATHS=()
	BRANCH_NAMES=()

	while IFS= read -r line; do
		WORKTREE_PATHS+=("$(extract_path_from_display_line "$line")")
		BRANCH_NAMES+=("$(extract_branch_from_display_line "$line")")
	done <<<"$selected"
}

delete_remote_branch() {
	# Delete a branch from the remote if it exists
	# Args: $1 = branch name
	# Returns: 0 if deleted or didn't exist, 1 if deletion failed
	# Outputs: status message describing what happened
	local branch=$1

	if git ls-remote --exit-code --heads origin "$branch" >/dev/null 2>&1; then
		if $CMD push origin --delete "$branch" 2>/dev/null; then
			echo "local and remote"
			return 0
		else
			echo "remote deletion failed"
			return 1
		fi
	else
		echo "no remote branch"
		return 0
	fi
}

remove_single_worktree() {
	# Remove a single worktree and optionally delete its branch
	# Args: $1 = worktree path, $2 = branch name (can be empty), $3 = mode ("remove" or "destroy")
	#       $4 = success prefix (optional), $5 = failure prefix (optional)
	# Returns: 0 on success, 1 on failure
	local worktree_path=$1
	local branch=$2
	local mode=$3
	local success_prefix=${4-}
	local failure_prefix=${5:-$success_prefix}
	local action_verb="Removed"
	local action_noun="remove"

	if [[ "$mode" == "destroy" ]]; then
		action_verb="Destroyed"
		action_noun="destroy"
	fi

	$CMD worktree remove -f "$worktree_path"
	local remove_exit=$?

	if [[ $remove_exit -ne 0 ]]; then
		echo "${failure_prefix}Failed to $action_noun worktree '$worktree_path'"
		return 1
	fi

	if [[ -z "$branch" ]]; then
		echo "${success_prefix}$action_verb worktree '$worktree_path'"
		return 0
	fi

	# Delete local branch
	$CMD branch -D "$branch" >/dev/null 2>&1 || true

	if [[ "$mode" == "destroy" ]]; then
		local remote_status
		remote_status=$(delete_remote_branch "$branch")
		echo "${success_prefix}$action_verb worktree '$worktree_path' and deleted branch '$branch' ($remote_status)"
	else
		echo "${success_prefix}$action_verb worktree '$worktree_path' and deleted local branch '$branch'"
	fi

	return 0
}

case ${1-} in
# This is an extra command that I added to handle cloning a repo and setting it
# up as a worktree
clone)
	shift

	# Handle --help flag
	if [[ "${1-}" == "--help" ]] || [[ "${1-}" == "-h" ]]; then
		cat <<-EOF
			git wt clone - Clone a repository with worktree structure

			Usage:
			  git wt clone <repository-url> [folder-name]

			Options:
			  --help, -h      Show this help message

			Examples:
			  git wt clone https://github.com/user/repo.git
			  git wt clone git@github.com:user/repo.git my-repo

			Note: Creates .bare directory structure and initial worktree for default branch
		EOF
		exit 0
	fi

	# Validate repository URL is provided
	if [[ -z "${1-}" ]]; then
		echo "Error: Repository URL is required" >&2
		echo "Usage: git wt clone <repository-url> [folder-name]" >&2
		exit 1
	fi

	REPO_URL="$1"
	FOLDER_NAME=${2:-$(basename "$REPO_URL" ".git")}

	# Check if directory already exists
	if [[ -d "$FOLDER_NAME" ]]; then
		echo "Error: Directory '$FOLDER_NAME' already exists" >&2
		exit 1
	fi

	# Create directory with error handling
	mkdir -p "$FOLDER_NAME" || {
		echo "Error: Failed to create directory '$FOLDER_NAME'" >&2
		exit 1
	}

	cd "$FOLDER_NAME" || {
		echo "Error: Failed to change to directory '$FOLDER_NAME'" >&2
		exit 1
	}

	# Clone with error handling and cleanup on failure
	$CMD clone --bare "$REPO_URL" .bare || {
		echo "Error: Failed to clone repository" >&2
		cd ..
		rm -rf "$FOLDER_NAME"
		exit 1
	}

	echo "gitdir: ./.bare" >.git

	$CMD config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"
	$CMD config core.logallrefupdates true
	$CMD config worktree.useRelativePaths true

	$CMD fetch --all || {
		echo "Warning: Failed to fetch all branches"
	}

	# Need to remove all local branches with invalid upstream refs
	# See: https://stackoverflow.com/a/54408181/213124
	$CMD for-each-ref --format='%(refname:short)' refs/heads | xargs $CMD branch -D 2>/dev/null || true

	echo "Discovering default branch..."
	default_branch=$(get_default_branch)

	if [[ -z "$default_branch" ]]; then
		echo "Warning: Could not discover default branch from remote"
		echo "Available branches:"
		git branch -r
		printf "Enter default branch name (or press Enter to skip): "
		read -r default_branch
	fi

	if [[ -n "$default_branch" ]]; then
		echo "Creating initial worktree for '$default_branch'..."
		$CMD worktree add -B "$default_branch" "$default_branch" "origin/$default_branch" || {
			echo "Warning: Failed to create worktree for default branch"
		}
	else
		echo "No worktree created. Use 'git wt add' to create worktrees."
	fi

	cat <<-EOF

		✓ Repository cloned successfully

		Repository structure:
		  $FOLDER_NAME/
		  ├── .bare/              (git data)
		  ├── .git                (pointer to .bare)
	EOF
	if [[ -n "$default_branch" ]]; then
		echo "  └── $default_branch/           (worktree)"
	fi
	cat <<-EOF

		To create additional worktrees:
		  cd $FOLDER_NAME
		  git wt add
	EOF

	;;
# Migrate an existing repository to use worktrees
# Takes the current git repo and converts it to a .bare + worktrees structure
# Preserves working directory state (modified files, staged changes, stashes)
migrate)
	shift

	# Check if we're in a git repository
	if ! git rev-parse --git-dir >/dev/null 2>&1; then
		echo "Error: Not in a git repository" >&2
		exit 1
	fi

	# Get the current repository root
	REPO_ROOT=$(git rev-parse --show-toplevel)
	REPO_NAME=$(basename "$REPO_ROOT")
	PARENT_DIR=$(dirname "$REPO_ROOT")

	# Get the current branch before we do anything
	CURRENT_BRANCH=$(git branch --show-current)

	if [[ -z "$CURRENT_BRANCH" ]]; then
		echo "Error: Not on a branch (detached HEAD state). Please check out a branch first." >&2
		exit 1
	fi

	# Get the remote URL to preserve it
	REMOTE_URL=""
	if git remote get-url origin >/dev/null 2>&1; then
		REMOTE_URL=$(git remote get-url origin)
		echo "Remote URL: $REMOTE_URL"
	else
		echo "Warning: No remote 'origin' found"
	fi

	# Discover the default branch from remote
	DEFAULT_BRANCH=""
	if [[ -n "$REMOTE_URL" ]]; then
		DEFAULT_BRANCH=$(get_default_branch)
	fi

	# Fallback: try common default branch names if remote detection fails
	if [[ -z "$DEFAULT_BRANCH" ]]; then
		for branch in main master; do
			if git rev-parse --verify "$branch" >/dev/null 2>&1; then
				DEFAULT_BRANCH="$branch"
				break
			fi
		done
	fi

	echo "Migrating repository: $REPO_NAME"
	echo "Current branch: $CURRENT_BRANCH"
	if [[ -n "$DEFAULT_BRANCH" ]]; then
		echo "Default branch: $DEFAULT_BRANCH"
	fi
	echo ""

	# Check if there are any changes (staged or unstaged)
	HAS_CHANGES=false
	if ! git diff-index --quiet HEAD -- 2>/dev/null; then
		HAS_CHANGES=true
		echo "Detected uncommitted changes - will preserve them in the new worktree"
	fi

	# Check if there are untracked files
	UNTRACKED_FILES=()
	while IFS= read -r file; do
		UNTRACKED_FILES+=("$file")
	done < <(git ls-files --others --exclude-standard)

	if [[ ${#UNTRACKED_FILES[@]} -gt 0 ]]; then
		echo "Detected ${#UNTRACKED_FILES[@]} untracked file(s) - will preserve them"
	fi

	# Store stash count to migrate later
	STASH_COUNT=$(git stash list | wc -l | tr -d ' ')
	if [[ "$STASH_COUNT" -gt 0 ]]; then
		echo "Detected $STASH_COUNT stash(es) - will migrate them"
	fi

	echo ""

	# Confirm with user
	printf "This will restructure the repository. Continue? [y/N]: "
	read -r CONFIRMATION

	if [[ "$CONFIRMATION" != "y" ]]; then
		echo "Migration cancelled."
		exit 0
	fi

	# Create temporary directory to hold migration work
	NEW_STRUCTURE="${PARENT_DIR}/${REPO_NAME}-new-$$"
	TEMP_BACKUP="${PARENT_DIR}/${REPO_NAME}-backup-$$"

	# Cleanup function for signal handling
	cleanup_migrate() {
		local exit_code=$?
		if [[ -d "$NEW_STRUCTURE" ]]; then
			rm -rf "$NEW_STRUCTURE"
		fi
		if [[ -d "$TEMP_BACKUP" ]]; then
			rm -rf "$TEMP_BACKUP"
		fi
		exit $exit_code
	}

	# Set trap to cleanup on interrupt or error
	trap cleanup_migrate INT TERM

	echo "Creating new repository structure..."
	mkdir -p "$NEW_STRUCTURE"
	cd "$NEW_STRUCTURE"

	# Clone the existing repo as bare into .bare
	echo "Converting to bare repository..."
	$CMD clone --bare "$REPO_ROOT" .bare

	# Create .git file pointing to .bare directory
	# This allows git commands to work from the parent directory without being inside a worktree
	echo "gitdir: ./.bare" >.git

	# Configure fetch refspec to get all remote branches
	# Bare repos by default use a different fetch refspec ("+refs/*:refs/*")
	# We need "+refs/heads/*:refs/remotes/origin/*" to properly track remote branches
	# This ensures all remote branches are visible and can be checked out as worktrees
	echo "Configuring bare repository..."
	$CMD config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"

	# Enable reflog in bare repository
	# Bare repos have core.logallrefupdates=false by default because they don't have a working tree
	# Setting this to true maintains reflog entries for all ref updates, which is essential for:
	# - git reflog (viewing history of ref changes)
	# - recovering lost commits
	# - undoing accidental branch deletions or resets
	# Without this, operations like "git reflog" wouldn't work properly
	$CMD config core.logallrefupdates true

	# Fetch all branches from remote if they exist
	if git remote get-url origin >/dev/null 2>&1; then
		echo "Fetching all branches from remote..."
		$CMD fetch --all
	fi

	# Clean up any local branches with invalid upstream refs
	# After converting to bare repo, some branch refs may be in an inconsistent state
	# This cleanup ensures we start fresh with only valid branch references
	$CMD for-each-ref --format='%(refname:short)' refs/heads | xargs $CMD branch -D 2>/dev/null || true

	# Fix the remote URL to point to the original remote instead of the local disk path
	# When we clone from a local path, git sets origin to that local path
	# We need to restore the original remote URL so fetch/push work correctly
	if [ -n "$REMOTE_URL" ]; then
		echo "Restoring remote URL..."
		$CMD remote set-url origin "$REMOTE_URL"
	fi

	# Migrate all stashes to the new bare repository
	# Stashes are stored in refs/stash, and we need to copy them to the new bare repo
	if [[ "$STASH_COUNT" -gt 0 ]]; then
		echo "Migrating $STASH_COUNT stash(es)..."
		# Copy the stash ref and reflog from old repo to new bare repo
		if [[ -f "$REPO_ROOT/.git/refs/stash" ]]; then
			cp "$REPO_ROOT/.git/refs/stash" "$NEW_STRUCTURE/.bare/refs/stash"
		fi
		if [[ -f "$REPO_ROOT/.git/logs/refs/stash" ]]; then
			mkdir -p "$NEW_STRUCTURE/.bare/logs/refs"
			cp "$REPO_ROOT/.git/logs/refs/stash" "$NEW_STRUCTURE/.bare/logs/refs/stash"
		fi
	fi

	# Create worktrees
	# If current branch is the default branch, only create one worktree
	# Otherwise, create worktrees for both default and current branches
	if [[ -n "$DEFAULT_BRANCH" ]] && [[ "$DEFAULT_BRANCH" = "$CURRENT_BRANCH" ]]; then
		echo "Creating worktree for $CURRENT_BRANCH (default branch)..."
		git -C "$NEW_STRUCTURE" worktree add "$CURRENT_BRANCH" "$CURRENT_BRANCH"
	else
		# Create worktree for default branch first if it exists
		if [[ -n "$DEFAULT_BRANCH" ]]; then
			echo "Creating worktree for default branch: $DEFAULT_BRANCH"
			git -C "$NEW_STRUCTURE" worktree add "$DEFAULT_BRANCH" "$DEFAULT_BRANCH"
		fi

		# Create worktree for current branch
		echo "Creating worktree for current branch: $CURRENT_BRANCH"
		git -C "$NEW_STRUCTURE" worktree add "$CURRENT_BRANCH" "$CURRENT_BRANCH"
	fi

	# Restore the working directory state to match the original repo
	# This includes ALL files on disk: tracked, modified, untracked, and gitignored
	echo "Restoring working directory state..."

	# Copy all files from the original repo to preserve the exact state
	# We use rsync to preserve file permissions, timestamps, and handle all edge cases
	# This copies:
	# - Tracked files (already in git)
	# - Modified files (tracked but with changes)
	# - Untracked files (not in git, not gitignored)
	# - Gitignored files (on disk but ignored by git)
	# Everything except .git directory itself (which we've replaced with .bare structure)
	rsync -a --exclude='.git' "$REPO_ROOT/" "$NEW_STRUCTURE/$CURRENT_BRANCH/"

	# Restore the git index (staged changes)
	# The index file contains information about staged changes
	# This ensures any staged changes are preserved in the new worktree
	if [[ -f "$REPO_ROOT/.git/index" ]]; then
		cp "$REPO_ROOT/.git/index" "$NEW_STRUCTURE/.bare/worktrees/$CURRENT_BRANCH/index"
	fi

	echo "Working directory state restored (all files preserved)"

	# Success - now replace the old repo with the new structure
	echo ""
	echo "Finalizing migration..."

	cd "$PARENT_DIR"
	mv "$REPO_ROOT" "$TEMP_BACKUP"
	mv "$NEW_STRUCTURE" "$REPO_ROOT"

	echo "Cleaning up..."
	rm -rf "$TEMP_BACKUP"

	cat <<-EOF

		✓ Migration complete!

		Your repository structure is now:
		  $REPO_ROOT/
		  ├── .bare/              (git data)
		  ├── .git                (pointer to .bare)
	EOF

	# Display worktree structure based on what was created
	if [[ -n "$DEFAULT_BRANCH" ]] && [[ "$DEFAULT_BRANCH" = "$CURRENT_BRANCH" ]]; then
		echo "  └── $CURRENT_BRANCH/           (worktree - default branch)"
	else
		if [[ -n "$DEFAULT_BRANCH" ]]; then
			echo "  ├── $DEFAULT_BRANCH/           (worktree - default branch)"
		fi
		echo "  └── $CURRENT_BRANCH/           (worktree - current branch)"
	fi
	echo ""

	if [[ -n "$REMOTE_URL" ]]; then
		echo "✓ Remote URL preserved: $REMOTE_URL"
	fi

	if [[ "$STASH_COUNT" -gt 0 ]]; then
		echo "✓ Migrated $STASH_COUNT stash(es)"
	fi

	if [[ "$HAS_CHANGES" = true ]]; then
		echo "✓ Preserved uncommitted changes in $CURRENT_BRANCH/"
	fi

	if [[ ${#UNTRACKED_FILES[@]} -gt 0 ]]; then
		echo "✓ Preserved ${#UNTRACKED_FILES[@]} untracked file(s) in $CURRENT_BRANCH/"
	fi

	cat <<-EOF

		To create additional worktrees:
		  cd $REPO_ROOT
		  git wt add <branch-name> <branch-name>

		To view migrated stashes:
		  cd $REPO_ROOT/$CURRENT_BRANCH
		  git stash list

		Navigate to your worktree:
		  cd $REPO_ROOT/$CURRENT_BRANCH
	EOF

	# Clear trap on successful completion
	trap - INT TERM

	;;
add)
	shift

	# Handle --help flag
	if [[ "${1-}" == "--help" ]] || [[ "${1-}" == "-h" ]]; then
		cat <<-EOF
			git wt add - Create a new worktree

			Usage:
			  git wt add                              Interactive mode (fzf)
			  git wt add <path> <commit-ish>          Create worktree from branch
			  git wt add -b <branch> <path>           Create new branch and worktree

			Options:
			  -b <branch>     Create new branch
			  -B <branch>     Create/reset branch
			  --help, -h      Show this help message

			Examples:
			  git wt add                               # Interactive selection
			  git wt add feature origin/feature        # From remote branch
			  git wt add -b new-feature new-feature    # New branch

			Note: Always fetches from origin to ensure up-to-date refs
		EOF
		exit 0
	fi

	# Fetch latest remote branches to ensure we have up-to-date refs
	echo "Fetching from origin..."
	$CMD fetch origin --prune

	# If no arguments provided, show interactive branch selector with fzf
	if [[ $# -eq 0 ]]; then
		check_fzf_dependency

		# Get list of remote branches (excluding HEAD)
		# Format: Strip 'origin/' prefix for cleaner display
		SELECTED=$(
			{
				echo "➕ Create new branch"
				$CMD branch -r --format='%(refname:short)' | grep -v HEAD | sed 's/^origin\///'
			} | fzf \
				--prompt="Select branch or create new: " \
				--height=40% \
				--border \
				--preview='
					if [[ {} == "➕ Create new branch" ]]; then
						echo "Create a new branch and worktree"
						echo ""
						echo "You will be prompted to enter:"
						echo "  • Branch name"
						echo "  • Worktree path (optional, defaults to branch name)"
					else
						echo "Branch: {}"
						echo ""
						echo "Recent commits:"
						git log --oneline --graph --date=short --color=always --pretty="format:%C(auto)%cd %h%d %s" origin/{} -10 --
					fi
				' \
				--preview-window=right:60%:wrap
		)

		# User cancelled
		if [[ -z "$SELECTED" ]]; then
			echo "Cancelled"
			exit 0
		fi

		# Handle "Create new branch" option
		if [[ "$SELECTED" == "➕ Create new branch" ]]; then
			printf "Enter new branch name: "
			read -r NEW_BRANCH

			if ! validate_branch_name "$NEW_BRANCH"; then
				exit 1
			fi

			printf "Enter worktree path [default: %s]: " "$NEW_BRANCH"
			read -r WORKTREE_PATH

			# Default to branch name if no path provided
			if [[ -z "$WORKTREE_PATH" ]]; then
				WORKTREE_PATH="$NEW_BRANCH"
			fi

			# Create new branch and worktree
			echo "Creating new branch '$NEW_BRANCH' and worktree at '$WORKTREE_PATH'..."
			$CMD worktree add -b "$NEW_BRANCH" "$WORKTREE_PATH"
			exit $?
		fi

		# Handle existing remote branch selection
		# Create worktree from the selected remote branch
		echo "Creating worktree for '$SELECTED' from origin/$SELECTED..."
		$CMD worktree add "$SELECTED" "origin/$SELECTED"
		WORKTREE_ADD_EXIT=$?

		# Set upstream tracking if worktree was created successfully
		if [[ $WORKTREE_ADD_EXIT -eq 0 ]]; then
			echo "Setting upstream to origin/$SELECTED"
			$CMD branch --set-upstream-to="origin/$SELECTED" "$SELECTED"
		fi

		exit $WORKTREE_ADD_EXIT
	fi

	# Arguments provided - proceed with normal argument parsing
	BRANCH=""
	ARGS=()

	# Parse arguments
	# Supports standard git worktree add flags
	# -b <branch>: Create new branch (standard git flag)
	# -B <branch>: Create/reset branch (standard git flag)
	while [[ $# -gt 0 ]]; do
		case $1 in
		-b | -B)
			# Capture branch name for upstream tracking
			BRANCH=$2
			ARGS+=("$1" "$2")
			shift 2
			;;
		*)
			ARGS+=("$1")
			shift
			;;
		esac
	done

	# Create the worktree
	# Pass all collected arguments to git worktree add
	$CMD worktree add "${ARGS[@]}"
	WORKTREE_ADD_EXIT=$?

	# Only proceed with upstream setup if worktree was created successfully
	if [[ $WORKTREE_ADD_EXIT -eq 0 ]] && [[ -n "$BRANCH" ]]; then
		# Set upstream tracking if the branch exists on origin
		# This enables git push/pull without specifying remote/branch
		if git rev-parse --verify "origin/$BRANCH" >/dev/null 2>&1; then
			echo "Setting upstream to origin/$BRANCH"
			$CMD branch --set-upstream-to="origin/$BRANCH" "$BRANCH"
		else
			# If we're creating a new local branch,
			# remind the user to push and set upstream
			cat <<-EOF

				Branch '$BRANCH' created locally.
				To push and set upstream:
				  git push -u origin $BRANCH
			EOF
		fi
	fi

	exit $WORKTREE_ADD_EXIT
	;;
remove | rm)
	shift

	# Handle --help flag
	if [[ "${1-}" == "--help" ]] || [[ "${1-}" == "-h" ]]; then
		cat <<-EOF
			git wt remove - Remove worktree(s) and delete local branch(es)

			Usage:
			  git wt remove                            Interactive mode (fzf)
			  git wt remove <path> [<path>...]         Remove specific worktree(s)
			  git wt remove --dry-run                  Preview without changes

			Options:
			  --dry-run, -n   Show what would be removed without making changes
			  --help, -h      Show this help message

			Examples:
			  git wt remove                            # Interactive selection
			  git wt remove feature-1 feature-2        # Remove multiple
			  git wt remove --dry-run                  # Preview in interactive mode
			  git wt remove -n feature-1 feature-2     # Preview specific worktrees

			Note: Remote branches are NOT deleted. Use 'destroy' for that.
		EOF
		exit 0
	fi

	# Parse flags
	DRY_RUN=false
	WORKTREE_ARGS=()

	while [[ $# -gt 0 ]]; do
		case $1 in
		--dry-run | -n)
			DRY_RUN=true
			shift
			;;
		*)
			WORKTREE_ARGS+=("$1")
			shift
			;;
		esac
	done

	# Interactive mode - select worktree(s) with fzf
	if [[ ${#WORKTREE_ARGS[@]} -eq 0 ]]; then
		check_fzf_dependency
		SELECTED=$(select_worktrees_interactive "remove")

		# Parse selected worktrees into arrays
		parse_selected_worktrees "$SELECTED"
		WORKTREES_TO_REMOVE=("${WORKTREE_PATHS[@]}")
		BRANCHES_TO_DELETE=("${BRANCH_NAMES[@]}")

		# Show what will be removed
		echo ""
		if [[ "$DRY_RUN" = true ]]; then
			echo "[DRY RUN] Would remove ${#WORKTREES_TO_REMOVE[@]} worktree(s):"
		else
			echo "About to remove ${#WORKTREES_TO_REMOVE[@]} worktree(s):"
		fi
		for i in "${!WORKTREES_TO_REMOVE[@]}"; do
			echo "  [$((i + 1))] ${WORKTREES_TO_REMOVE[$i]} (branch: ${BRANCHES_TO_DELETE[$i]})"
		done
		echo ""
		echo "Note: Remote branches will NOT be deleted"
		echo ""

		if [[ "$DRY_RUN" = true ]]; then
			echo "[DRY RUN] No changes made"
			exit 0
		fi

		printf "Continue? [y/N]: "
		read -r CONFIRMATION

		if [[ "$CONFIRMATION" != "y" ]]; then
			echo "Cancelled"
			exit 0
		fi

		# Remove worktrees and delete branches
		echo ""
		FAILED_COUNT=0
		SUCCESS_COUNT=0

		for i in "${!WORKTREES_TO_REMOVE[@]}"; do
			WORKTREE_PATH="${WORKTREES_TO_REMOVE[$i]}"
			BRANCH="${BRANCHES_TO_DELETE[$i]}"

			echo "[$((i + 1))/${#WORKTREES_TO_REMOVE[@]}] Removing $WORKTREE_PATH..."

			if remove_single_worktree "$WORKTREE_PATH" "$BRANCH" "remove" "  ✓ " "  ✗ "; then
				SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
			else
				FAILED_COUNT=$((FAILED_COUNT + 1))
			fi
		done

		echo ""
		echo "Summary: $SUCCESS_COUNT succeeded, $FAILED_COUNT failed"

		if [[ $FAILED_COUNT -gt 0 ]]; then
			exit 1
		fi

		exit 0
	fi

	# Non-interactive mode - worktree path(s) provided as arguments
	# Support multiple worktrees as arguments
	FAILED_COUNT=0
	SUCCESS_COUNT=0

	# Validate all worktree paths first
	for WORKTREE_PATH in "${WORKTREE_ARGS[@]}"; do
		if ! validate_worktree "$WORKTREE_PATH"; then
			exit 1
		fi
	done

	# Show what will be removed in dry-run mode
	if [[ "$DRY_RUN" = true ]]; then
		echo "[DRY RUN] Would remove ${#WORKTREE_ARGS[@]} worktree(s):"
		for WORKTREE_PATH in "${WORKTREE_ARGS[@]}"; do
			BRANCH=$(get_worktree_branch "$WORKTREE_PATH")
			if [[ -n "$BRANCH" ]]; then
				echo "  - $WORKTREE_PATH (branch: $BRANCH)"
			else
				echo "  - $WORKTREE_PATH"
			fi
		done
		echo ""
		echo "[DRY RUN] No changes made"
		exit 0
	fi

	for WORKTREE_PATH in "${WORKTREE_ARGS[@]}"; do
		BRANCH_TO_DELETE=$(get_worktree_branch "$WORKTREE_PATH")

		if remove_single_worktree "$WORKTREE_PATH" "$BRANCH_TO_DELETE" "remove"; then
			SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
		else
			FAILED_COUNT=$((FAILED_COUNT + 1))
		fi
	done

	if [[ ${#WORKTREE_ARGS[@]} -gt 1 ]]; then
		echo ""
		echo "Summary: $SUCCESS_COUNT succeeded, $FAILED_COUNT failed"
	fi

	if [[ $FAILED_COUNT -gt 0 ]]; then
		exit 1
	fi

	exit 0
	;;
# Same as remove, but this time we also delete the branch from remote
destroy)
	shift

	# Handle --help flag
	if [[ "${1-}" == "--help" ]] || [[ "${1-}" == "-h" ]]; then
		cat <<-EOF
			git wt destroy - Remove worktree(s) and delete LOCAL and REMOTE branch(es)

			Usage:
			  git wt destroy                           Interactive mode (fzf)
			  git wt destroy <path> [<path>...]        Destroy specific worktree(s)
			  git wt destroy --dry-run                 Preview without changes

			Options:
			  --dry-run, -n   Show what would be destroyed without making changes
			  --help, -h      Show this help message

			Examples:
			  git wt destroy                           # Interactive selection
			  git wt destroy feature-1 feature-2       # Destroy multiple
			  git wt destroy --dry-run                 # Preview in interactive mode
			  git wt destroy -n feature-1 feature-2    # Preview specific worktrees

			Warning: This deletes both local AND remote branches permanently.
		EOF
		exit 0
	fi

	# Parse flags
	DRY_RUN=false
	WORKTREE_ARGS=()

	while [[ $# -gt 0 ]]; do
		case $1 in
		--dry-run | -n)
			DRY_RUN=true
			shift
			;;
		*)
			WORKTREE_ARGS+=("$1")
			shift
			;;
		esac
	done

	# Interactive mode - select worktree(s) with fzf
	if [[ ${#WORKTREE_ARGS[@]} -eq 0 ]]; then
		check_fzf_dependency
		SELECTED=$(select_worktrees_interactive "destroy")

		# Parse selected worktrees into arrays
		parse_selected_worktrees "$SELECTED"
		WORKTREES_TO_DESTROY=("${WORKTREE_PATHS[@]}")
		BRANCHES_TO_DELETE=("${BRANCH_NAMES[@]}")

		# Show what will be destroyed
		echo ""
		if [[ "$DRY_RUN" = true ]]; then
			echo "[DRY RUN] Would DESTROY ${#WORKTREES_TO_DESTROY[@]} worktree(s):"
		else
			echo "⚠️  WARNING: DESTRUCTIVE OPERATION"
			echo ""
			echo "About to DESTROY ${#WORKTREES_TO_DESTROY[@]} worktree(s):"
		fi
		for i in "${!WORKTREES_TO_DESTROY[@]}"; do
			echo "  [$((i + 1))] ${WORKTREES_TO_DESTROY[$i]} (branch: ${BRANCHES_TO_DELETE[$i]})"
		done
		cat <<-EOF

			This will:
			  - Remove worktree directories
			  - Delete local branches
			  - Delete remote branches (origin/<branch>)

		EOF

		if [[ "$DRY_RUN" = true ]]; then
			echo "[DRY RUN] No changes made"
			exit 0
		fi

		cat <<-EOF
			This action CANNOT be undone.

		EOF

		# For single selection, require exact branch name
		# For multiple selections, use 'destroy' confirmation (typing multiple branch names would be tedious)
		if [[ ${#WORKTREES_TO_DESTROY[@]} -eq 1 ]]; then
			printf "Type the branch name to confirm: "
			read -r CONFIRMATION

			if [[ "$CONFIRMATION" != "${BRANCHES_TO_DELETE[0]}" ]]; then
				echo "Cancelled (confirmation did not match branch name)"
				exit 0
			fi
		else
			printf "Type 'destroy' to confirm: "
			read -r CONFIRMATION

			if [[ "$CONFIRMATION" != "destroy" ]]; then
				echo "Cancelled (must type 'destroy' to confirm)"
				exit 0
			fi
		fi

		# Remove worktrees and delete branches
		echo ""
		FAILED_COUNT=0
		SUCCESS_COUNT=0

		for i in "${!WORKTREES_TO_DESTROY[@]}"; do
			WORKTREE_PATH="${WORKTREES_TO_DESTROY[$i]}"
			BRANCH="${BRANCHES_TO_DELETE[$i]}"

			echo "[$((i + 1))/${#WORKTREES_TO_DESTROY[@]}] Destroying $WORKTREE_PATH..."

			if remove_single_worktree "$WORKTREE_PATH" "$BRANCH" "destroy" "  ✓ " "  ✗ "; then
				SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
			else
				FAILED_COUNT=$((FAILED_COUNT + 1))
			fi
		done

		echo ""
		echo "Summary: $SUCCESS_COUNT succeeded, $FAILED_COUNT failed"

		if [[ $FAILED_COUNT -gt 0 ]]; then
			exit 1
		fi

		exit 0
	fi

	# Non-interactive mode - worktree path(s) provided as arguments
	# Support multiple worktrees as arguments
	FAILED_COUNT=0
	SUCCESS_COUNT=0

	# Validate all worktree paths first
	for WORKTREE_PATH in "${WORKTREE_ARGS[@]}"; do
		if ! validate_worktree "$WORKTREE_PATH"; then
			exit 1
		fi
	done

	# Show what will be destroyed in dry-run mode
	if [[ "$DRY_RUN" = true ]]; then
		echo "[DRY RUN] Would DESTROY ${#WORKTREE_ARGS[@]} worktree(s):"
		for WORKTREE_PATH in "${WORKTREE_ARGS[@]}"; do
			BRANCH=$(get_worktree_branch "$WORKTREE_PATH")
			if [[ -n "$BRANCH" ]]; then
				cat <<-EOF
					  - $WORKTREE_PATH (branch: $BRANCH)
					    • Remove worktree directory
					    • Delete local branch: $BRANCH
					    • Delete remote branch: origin/$BRANCH
				EOF
			else
				echo "  - $WORKTREE_PATH"
			fi
		done
		cat <<-EOF

			[DRY RUN] No changes made
		EOF
		exit 0
	fi

	# Prompt for confirmation once before processing all worktrees
	FIRST_BRANCH=$(get_worktree_branch "${WORKTREE_ARGS[0]}")
	EXTRA_MSG=""
	if [[ -n "$FIRST_BRANCH" ]]; then
		EXTRA_MSG=" and delete its remote branch [$FIRST_BRANCH]"
	fi

	printf "Are you sure you want to destroy '%s' workspace%s? " "${WORKTREE_ARGS[0]}" "$EXTRA_MSG"
	if [[ ${#WORKTREE_ARGS[@]} -gt 1 ]]; then
		printf "(and %d more) " $((${#WORKTREE_ARGS[@]} - 1))
	fi
	printf "[y/N]: "
	read -r CONFIRMATION

	if [[ "$CONFIRMATION" != "y" ]]; then
		echo "Cancelled"
		exit 1
	fi

	for WORKTREE_ARG in "${WORKTREE_ARGS[@]}"; do
		BRANCH_TO_DELETE=$(get_worktree_branch "$WORKTREE_ARG")

		if remove_single_worktree "$WORKTREE_ARG" "$BRANCH_TO_DELETE" "destroy"; then
			SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
		else
			FAILED_COUNT=$((FAILED_COUNT + 1))
		fi
	done

	if [[ ${#WORKTREE_ARGS[@]} -gt 1 ]]; then
		echo ""
		echo "Summary: $SUCCESS_COUNT succeeded, $FAILED_COUNT failed"
	fi

	if [[ $FAILED_COUNT -gt 0 ]]; then
		exit 1
	fi

	exit 0
	;;

update | u)
	shift

	# Handle --help flag
	if [[ "${1-}" == "--help" ]] || [[ "${1-}" == "-h" ]]; then
		cat <<-EOF
			git wt update - Fetch and update the default branch worktree

			Usage:
			  git wt update                            Fetch all and pull default branch
			  git wt u                                 Alias for update

			Options:
			  --help, -h      Show this help message

			Example:
			  git wt update                            # Fetch all, then pull main/master
		EOF
		exit 0
	fi

	echo "Fetching from all remotes..."
	$CMD fetch --all --prune --prune-tags

	# Discover the default branch
	default_branch=$(get_default_branch)

	if [[ -z "$default_branch" ]]; then
		echo "Error: Could not determine default branch from remote" >&2
		exit 1
	fi

	# Find the worktree for the default branch
	default_worktree=$(get_worktree_path_for_branch "$default_branch")

	if [[ -z "$default_worktree" ]]; then
		echo "Error: No worktree found for default branch '$default_branch'" >&2
		echo "Available worktrees:" >&2
		git worktree list >&2
		exit 1
	fi

	echo "Updating default branch '$default_branch' in $default_worktree..."
	git -C "$default_worktree" pull
	;;

switch)
	shift

	# Handle --help flag
	if [[ "${1-}" == "--help" ]] || [[ "${1-}" == "-h" ]]; then
		cat <<-EOF
			git wt switch - Interactively switch to a different worktree

			Usage:
			  cd \$(git wt switch)                      Change to selected worktree
			  git wt switch                            Print selected worktree path

			Options:
			  --help, -h      Show this help message

			Example:
			  cd \$(git wt switch)                      # Select worktree and cd into it
		EOF
		exit 0
	fi

	check_fzf_dependency

	WORKTREE_LIST=$(build_worktree_display_list)

	if [[ -z "$WORKTREE_LIST" ]]; then
		echo "No worktrees available"
		exit 0
	fi

	SELECTED=$(
		echo "$WORKTREE_LIST" | fzf \
			--prompt="Switch to worktree: " \
			--height=60% \
			--border \
			--preview="
				WORKTREE_PATH=\$(echo {} | awk '{print \$1}')
				BRANCH=\$(echo {} | sed -E 's/.*\[([^]]+)\].*/\1/')

				echo \"Worktree: \$WORKTREE_PATH\"
				echo \"Branch: \$BRANCH\"
				echo \"\"
				echo \"Status:\"
				git -c color.status=always -C \"\$WORKTREE_PATH\" status --short --branch 2>/dev/null || echo \"(unable to get status)\"
				echo \"\"
				echo \"Recent commits:\"
				git log --oneline --graph --date=short --color=always --pretty='format:%C(auto)%cd %h%d %s' \"\$BRANCH\" -10 -- 2>/dev/null || echo \"(unable to get log)\"
			" \
			--preview-window=right:60%:wrap
	)

	if [[ -n "$SELECTED" ]]; then
		WORKTREE_PATH=$(extract_path_from_display_line "$SELECTED")
		# Output the path for the user to cd into
		# Usage: cd $(git wt switch) or use shell integration
		echo "$WORKTREE_PATH"
	fi
	;;
list)
	shift

	# Handle --help flag
	if [[ "${1-}" == "--help" ]] || [[ "${1-}" == "-h" ]]; then
		cat <<-EOF
			git wt list - List all worktrees

			Usage:
			  git wt list                              List all worktrees

			Options:
			  --help, -h      Show this help message

			Note: This is a wrapper around 'git worktree list'
		EOF
		exit 0
	fi

	$CMD worktree list "$@"
	;;
lock | unlock | move | prune | repair)
	$CMD worktree "$@"
	;;

"" | help | --help)
	cat <<-'EOF'
		  Run: git worktree --help for worktree help
		  -------------------------------------------------------------------------------
			Additional commands (use --help on each for details):

			git-wt <command> --help                      Show help for a specific command

			git-wt clone <repo> [folder-name]
			    Clone a repository and set it up with worktree structure
			    Creates .bare directory for git data and initial worktree for default branch

			git-wt migrate
			    Migrate an existing repository to use worktrees
			    Converts current repo to .bare + worktrees structure
			    Preserves: uncommitted changes, staged changes, untracked files, and stashes
			    Must be run from within the repository to migrate

			git-wt add [options] [<path>] [<commit-ish>]
			    Create a new worktree (enhanced wrapper around git worktree add)
			    Always fetches latest refs from origin before creating worktree

			    Interactive mode (no arguments):
			      git wt add
			          Opens fzf to select from remote branches or create new branch
			          - Fetches latest remote refs first
			          - Shows git log preview for each remote branch
			          - Option to create new branch with custom name and path
			          - Automatically sets up upstream tracking

			    Standard git worktree flags:
			      -b <branch>     Create new branch
			      -B <branch>     Create/reset branch
			      All other git worktree add flags are supported

			    Upstream tracking:
			      - Automatically sets upstream when using -b if branch exists on origin
			      - Always sets upstream in interactive mode
			      - Provides helpful push instructions for new local branches

			    Examples:
			      git wt add
			          Interactive mode - select branch with fzf

			      git wt add feature origin/feature
			          Create worktree from remote branch

			      git wt add -b new-feature new-feature
			          Create new branch and worktree

			      git wt add existing-branch
			          Create worktree from existing local branch

			git-wt remove|rm [options] [<worktree>...]
			    Remove worktree(s) and delete local branch(es)
			    Does NOT delete branches from remote

			    Options:
			      --dry-run, -n    Show what would be removed without making changes

			    Interactive mode (no arguments):
			      git wt remove
			          Opens fzf to select worktree(s) to remove
			          - Use TAB to select multiple worktrees
			          - Shows git status and log preview
			          - Lists all selected worktrees before confirmation
			          - Shows progress for each worktree
			          - Removes worktrees and deletes local branches only

			    Direct mode (with arguments):
			      git wt remove <worktree-path> [<worktree-path>...]
			          Removes specified worktree(s) and deletes local branch(es)
			          Supports multiple worktrees as arguments

			    Examples:
			      git wt remove --dry-run
			          Preview what would be removed (interactive)

			      git wt remove -n feature-1 feature-2
			          Preview removing multiple worktrees (direct)

			git-wt destroy [options] [<worktree>...]
			    Remove worktree(s), delete local branch(es), AND delete from remote
			    Use this when you're completely done with feature branch(es)

			    Options:
			      --dry-run, -n    Show what would be destroyed without making changes

			    Interactive mode (no arguments):
			      git wt destroy
			          Opens fzf to select worktree(s) to destroy
			          - Use TAB to select multiple worktrees
			          - Shows warning about permanent deletion
			          - Shows git status and log preview
			          - Single selection: requires typing exact branch name
			          - Multiple selection: requires typing 'destroy'
			          - Shows progress for each worktree
			          - Removes worktrees, deletes local and remote branches

			    Direct mode (with arguments):
			      git wt destroy <worktree-path> [<worktree-path>...]
			          Destroys specified worktree(s)
			          Prompts for confirmation before destroying
			          Supports multiple worktrees as arguments

			    Examples:
			      git wt destroy --dry-run
			          Preview what would be destroyed (interactive)

			      git wt destroy -n feature-1 feature-2
			          Preview destroying multiple worktrees with full details

			git-wt update|u
			    Fetch all remotes and update the default branch worktree
			    Runs: git fetch --all --prune --prune-tags
			    Then pulls the default branch (main/master) in its worktree

			    Example:
			      git wt update                            # Fetch and pull default branch
			      git wt u                                 # Alias for update

			git-wt switch
			    Interactively select a worktree and print its path
			    Use with cd: cd $(git wt switch)
			    Shows git status and log preview for each worktree

			    Example:
			      cd $(git wt switch)                      # Select and change to worktree

			git-wt list
			    List all worktrees (wrapper around git worktree list)
	EOF
	;;
*)
	# Let git worktree handle the errors
	$CMD worktree "$@"
	;;
esac
