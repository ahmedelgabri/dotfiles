diff --git a/pure.zsh b/pure.zsh
index 80f0a8e..7348c36 100644
--- a/pure.zsh
+++ b/pure.zsh
@@ -126,6 +126,12 @@ prompt_pure_preprompt_render() {
 	# Update git branch color based on cache state.
 	typeset -g prompt_pure_git_branch_color=$prompt_pure_colors[git:branch]
 	[[ -n ${prompt_pure_git_last_dirty_check_timestamp+x} ]] && prompt_pure_git_branch_color=$prompt_pure_colors[git:branch:cached]
+	# At a worktree root, override the branch display with a worktree symbol.
+	if [[ -n $prompt_pure_vcs_info[worktree_root] ]]; then
+		prompt_pure_git_branch_color=$prompt_pure_colors[git:worktree]
+		typeset -gA prompt_pure_vcs_info
+		prompt_pure_vcs_info[branch]=${PURE_GIT_WORKTREE_SYMBOL:-â‰¡}
+	fi
 
 	# Update psvar values. PROMPT uses %(NV.true.false) to conditionally
 	# render each part. See prompt_pure_setup for the PROMPT template.
@@ -248,6 +254,9 @@ prompt_pure_async_git_aliases() {
 prompt_pure_async_vcs_info() {
 	setopt localoptions noshwordsplit
 
+	# Receive cached values from previous run.
+	local prev_top=$1 prev_worktree_root=$2
+
 	# Configure `vcs_info` inside an async task. This frees up `vcs_info`
 	# to be used or configured as the user pleases.
 	zstyle ':vcs_info:*' enable git
@@ -266,6 +275,34 @@ prompt_pure_async_vcs_info() {
 	info[top]=$vcs_info_msg_1_
 	info[action]=$vcs_info_msg_2_
 
+	# Detect worktree root when using relative worktree paths (git 2.25+).
+	# At a worktree root (parent of worktrees), we want to show a symbol instead of branch.
+	# Detection: bare repo where git-dir == git-common-dir but neither is ".git" (regular repo).
+	# Note: vcs_info may still return the bare repo's HEAD branch, so we check regardless.
+	# Optimization: use cached value if git context (top) hasn't changed.
+	if [[ -n $prev_top && $info[top] == $prev_top && -n $prev_worktree_root ]]; then
+		# Same git context with known worktree root - use cached value.
+		info[branch]=
+		info[worktree_root]=1
+	else
+		# Check if this is a worktree root. Only run if is_bare (cheap check first).
+		local is_bare
+		is_bare=$(command git rev-parse --is-bare-repository 2>/dev/null)
+
+		if [[ $is_bare == "true" ]]; then
+			local git_dir git_common_dir
+			git_dir=$(command git rev-parse --git-dir 2>/dev/null)
+			git_common_dir=$(command git rev-parse --git-common-dir 2>/dev/null)
+
+			# Worktree root: git_dir == git_common_dir but not ".git"
+			if [[ -n $git_dir && $git_dir == $git_common_dir && $git_dir != ".git" ]]; then
+				info[top]=$PWD
+				info[branch]=
+				info[worktree_root]=1
+			fi
+		fi
+	fi
+
 	print -r - ${(@kvq)info}
 }
 
@@ -417,10 +454,12 @@ prompt_pure_async_tasks() {
 		unset prompt_pure_git_fetch_pattern
 		prompt_pure_vcs_info[branch]=
 		prompt_pure_vcs_info[top]=
+		prompt_pure_vcs_info[worktree_root]=
 	fi
 	unset MATCH MBEGIN MEND
 
-	async_job "prompt_pure" prompt_pure_async_vcs_info
+	# Pass previous top and worktree_root to async worker for caching.
+	async_job "prompt_pure" prompt_pure_async_vcs_info "$prompt_pure_vcs_info[top]" "$prompt_pure_vcs_info[worktree_root]"
 
 	# Only perform tasks inside a Git working tree.
 	[[ -n $prompt_pure_vcs_info[top] ]] || return
@@ -533,10 +572,11 @@ prompt_pure_async_callback() {
 			# Git directory. Run the async refresh tasks.
 			[[ -n $info[top] ]] && [[ -z $prompt_pure_vcs_info[top] ]] && prompt_pure_async_refresh
 
-			# Always update branch, top-level and stash.
+			# Always update branch, top-level, action, and worktree_root.
 			prompt_pure_vcs_info[branch]=$info[branch]
 			prompt_pure_vcs_info[top]=$info[top]
 			prompt_pure_vcs_info[action]=$info[action]
+			prompt_pure_vcs_info[worktree_root]=$info[worktree_root]
 
 			do_render=1
 			;;
@@ -811,6 +851,7 @@ prompt_pure_setup() {
 		git:branch:cached    red
 		git:action           yellow
 		git:dirty            218
+		git:worktree         242
 		host                 242
 		path                 blue
 		prompt:error         red
